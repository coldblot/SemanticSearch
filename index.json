[
  {
    "name": "app",
    "extension": ".js",
    "content": "const express=require('express');\r\nconst fsp=require('fs').promises;\r\nconst fs=require('fs');\r\nconst path=require('path'); \r\nconst database = require('better-sqlite3');\r\n\r\nconst db=new database('rag.db', { verbose: console.log });\r\n\r\nconst app=express();\r\n\r\napp.use(express.json());\r\napp.use(express.urlencoded({ extended: true }));\r\n\r\n\r\napp.get('/executedb', (req, res) => {\r\n\r\n    try\r\n    {\r\n        db.exec(`\r\n            Create table if not exists files(\r\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                name TEXT,\r\n                content TEXT,\r\n                path TEXT,\r\n                embedding TEXT\r\n            )\r\n        `);\r\n        res.status(200).json({ message: 'Database executed successfully' });\r\n    }\r\n    catch (error) {\r\n        console.error('Error creating table:', error);\r\n        return res.status(500).json({ error: 'Failed to create table' });\r\n    }\r\n})\r\n\r\nasync function getEmbedding(text) {\r\n    const response = await openai.embeddings.create({\r\n      model: 'text-embedding-ada-002',\r\n      input: text\r\n    });\r\n    return response.data[0].embedding;\r\n  }\r\n\r\n  async function indexFile(name, path, content) {\r\n    const embedding = await getEmbedding(content);\r\n\r\n    console.log('Embedding for', name, ':', embedding);\r\n\r\n    db.prepare(`\r\n      INSERT INTO files (name, path, content, embedding)\r\n      VALUES (?, ?, ?, ?)\r\n    `).run(name, path, content, JSON.stringify(embedding));\r\n  }\r\n\r\napp.get('/search', async (req, res) => {\r\n    const  {name}  = req.query;\r\n   \r\n\r\n    if (!name) {\r\n        return res.status(400).json({ error: 'Missing name parameter' });\r\n    }\r\n\r\n    try {\r\n        const fileData = await fsp.readFile('index.json', 'utf8');\r\n        const index = JSON.parse(fileData);\r\n\r\n\r\n        // console.log(index);\r\n        const filtered = index.filter(file =>\r\n            file.name.toLowerCase().includes(name.toLowerCase()) || \r\n            file.content.toLowerCase().includes(name.toLowerCase()) ||\r\n            file.extension.toLowerCase().includes(name.toLowerCase())\r\n        );\r\n       \r\n        console.log(filtered.length);\r\n        if(filtered.length===0){\r\n            return res.status(404).json({ message: 'No files found' });\r\n        }\r\n\r\n        filtered.forEach(element => {\r\n            console.log(element.name, element.extension);\r\n        });\r\n        // res.json(filtered);\r\n    } catch (err) {\r\n        console.error('Error in /search:', err);\r\n        res.status(500).json({ error: 'Failed to search index' });\r\n    }\r\n\r\n})\r\nconst OpenAI = require('openai');\r\nconst openai = new OpenAI({apiKey:\"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\"});\r\n\r\n\r\napp.get('/ask', async (req, res) => {\r\n    const { query } = req.query;\r\n    \r\n    const response=await askAI(query);\r\n    return res.status(200).json({ response: response });\r\n});\r\n\r\nasync function askAI(query) {\r\n\r\n    const fileData = await fsp.readFile('index.json', 'utf8');\r\n    const index = JSON.parse(fileData);\r\n\r\n    console.log('Index:', index);\r\n\r\n    const prompt = `Given this file index:\\n${JSON.stringify(index, null, 2)}\\n\\nFind files relevant to: \"${query}\"`;\r\n\r\n    const response = await openai.chat.completions.create({\r\n        model: 'gpt-3.5-turbo',\r\n        messages: [{ role: 'user', content: prompt }],\r\n    });\r\n\r\n    // console.log('AI Response:', response.choices[0].message.content);\r\n    return response.choices[0].message.content;\r\n}\r\n\r\napp.get('/files', async (req, res) => {\r\n\r\n    const directorypath = path.dirname(__filename);\r\n    const directoryPath = await fsp.readdir(directorypath); \r\n    \r\n    let fullPath=[];\r\n\r\n    let index=[]\r\n    for (const entry of directoryPath) {\r\n        const fullPath = path.join(directorypath, entry);\r\n        const stat = await fsp.stat(fullPath);\r\n\r\n        if (stat.isFile()) {\r\n            const extension = path.extname(entry).toLowerCase();\r\n            const name = path.basename(entry, extension);\r\n\r\n            const content = await streamData(fullPath);\r\n\r\n            index.push({\r\n                name,\r\n                extension,\r\n                content\r\n            });\r\n            await indexFile(entry, fullPath, content);\r\n        }\r\n\r\n       \r\n\r\n        fs.writeFile('index.json', JSON.stringify(index, null, 2), (err) => {\r\n            if (err) {\r\n                console.error('Error writing to file', err);\r\n            } else {\r\n                console.log('File written successfully');\r\n            }\r\n        });\r\n        // console.log(index);\r\n\r\n    }\r\n   });\r\n\r\n   const streamData=(filePath)=>{\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const readStream = fs.createReadStream(filePath, {\r\n            encoding: 'utf8'\r\n        });\r\n\r\n        let content = '';\r\n\r\n        readStream.on('data', chunk => {\r\n            content += chunk;\r\n            console.log('Chunk received:', chunk);\r\n            readStream.destroy(); // Stop after first chunk\r\n        });\r\n\r\n        readStream.on('close', () => resolve(content));\r\n        readStream.on('error', reject);\r\n    });\r\n   }\r\n\r\n\r\n   \r\napp.listen(2500,()=>{\r\n    console.log('Server is running on port 3000');\r\n});\r\n"
  }
]